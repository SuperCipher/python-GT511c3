'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = main;

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _graphql = require('graphql');

var _graphqlLanguageServiceInterface = require('graphql-language-service-interface');

var _graphqlLanguageServiceUtils = require('graphql-language-service-utils');

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var GRAPHQL_SUCCESS_CODE = 0; /**
                               *  Copyright (c) Facebook, Inc.
                               *  All rights reserved.
                               *
                               *  This source code is licensed under the license found in the
                               *  LICENSE file in the root directory of this source tree.
                               *
                               *  
                               */

var GRAPHQL_FAILURE_CODE = 1;

/**
 * Performs GraphQL language service features with provided arguments from
 * the command-line interface.
 *
 * `autocomplete`: returns GraphQL autocomplete suggestions at the cursor
 *                 location provided, or at the end of the query text.
 * `outline`: returns GraphQL query outline information.
 * `validate`: performs GraphQL query lint/validations and returns the results.
 *             Query validation is only performed if a schema path is supplied.
 */

function main(command, argv) {
  var filePath = argv.file && argv.file.trim();
  (0, _assert2.default)(argv.text || argv.file, 'A path to the GraphQL file or its contents is required.');

  var text = ensureText(argv.text, filePath);
  var schemaPath = argv.schemaPath && argv.schemaPath.trim();

  var exitCode = void 0;
  switch (command) {
    case 'autocomplete':
      var lines = text.split('\n');
      var row = argv.row || lines.length - 1;
      var column = argv.column || lines[lines.length - 1].length;
      var point = new _graphqlLanguageServiceUtils.Position(row, column);
      exitCode = _getAutocompleteSuggestions(text, point, schemaPath);
      break;
    case 'outline':
      exitCode = _getOutline(text);
      break;
    case 'validate':
      exitCode = _getDiagnostics(filePath, text, schemaPath);
      break;
    default:
      throw new Error('Unknown command \'' + command + '\'');
  }

  process.exit(exitCode);
}

function _getAutocompleteSuggestions(queryText, point, schemaPath) {
  (0, _assert2.default)(schemaPath, 'A schema path is required to provide GraphQL autocompletion');

  try {
    var schema = schemaPath ? generateSchema(schemaPath) : null;
    var resultArray = schema ? (0, _graphqlLanguageServiceInterface.getAutocompleteSuggestions)(schema, queryText, point) : [];
    var resultObject = resultArray.reduce(function (prev, cur, index) {
      prev[index] = cur;
      return prev;
    }, {});
    process.stdout.write(JSON.stringify(resultObject, null, 2));
    return GRAPHQL_SUCCESS_CODE;
  } catch (error) {
    process.stderr.write(error);
    return GRAPHQL_FAILURE_CODE;
  }
}

function _getDiagnostics(filePath, queryText, schemaPath) {
  try {
    // `schema` is not strictly requied as GraphQL diagnostics may still notify
    // whether the query text is syntactically valid.
    var schema = schemaPath ? generateSchema(schemaPath) : null;
    var resultArray = (0, _graphqlLanguageServiceInterface.getDiagnostics)(queryText, schema);
    var resultObject = resultArray.reduce(function (prev, cur, index) {
      prev[index] = cur;
      return prev;
    }, {});
    process.stdout.write(JSON.stringify(resultObject, null, 2));
    return GRAPHQL_SUCCESS_CODE;
  } catch (error) {
    process.stderr.write(error);
    return GRAPHQL_FAILURE_CODE;
  }
}

function _getOutline(queryText) {
  try {
    var outline = (0, _graphqlLanguageServiceInterface.getOutline)(queryText);
    process.stdout.write(JSON.stringify(outline, null, 2));
  } catch (error) {
    process.stderr.write(error);
    return GRAPHQL_FAILURE_CODE;
  }
  return GRAPHQL_SUCCESS_CODE;
}

function ensureText(queryText, filePath) {
  var text = queryText;
  // Always honor text argument over filePath.
  // If text isn't available, try reading from the filePath.
  if (!text) {
    try {
      text = _fs2.default.readFileSync(filePath, 'utf8');
    } catch (error) {
      throw new Error(error);
    }
  }
  return text;
}

function generateSchema(schemaPath) {
  var schemaDSL = _fs2.default.readFileSync(schemaPath, 'utf8');
  var schemaFileExt = _path2.default.extname(schemaPath);
  switch (schemaFileExt) {
    case '.graphql':
      return (0, _graphql.buildSchema)(schemaDSL);
    case '.json':
      return (0, _graphql.buildClientSchema)(JSON.parse(schemaDSL));
    default:
      throw new Error('Unsupported schema file extention');
  }
}