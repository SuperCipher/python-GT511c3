'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MessageProcessor = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.getQueryAndRange = getQueryAndRange;

var _path = require('path');

var _url = require('url');

var _graphqlConfig = require('graphql-config');

var _graphqlLanguageServiceInterface = require('graphql-language-service-interface');

var _graphqlLanguageServiceUtils = require('graphql-language-service-utils');

var _vscodeJsonrpc = require('vscode-jsonrpc');

var _vscodeLanguageserver = require('vscode-languageserver');

var _GraphQLCache = require('./GraphQLCache');

var _findGraphQLTags = require('./findGraphQLTags');

var _Logger = require('./Logger');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /**
                                                                                                                                                           *  Copyright (c) Facebook, Inc.
                                                                                                                                                           *  All rights reserved.
                                                                                                                                                           *
                                                                                                                                                           *  This source code is licensed under the license found in the
                                                                                                                                                           *  LICENSE file in the root directory of this source tree.
                                                                                                                                                           *
                                                                                                                                                           *  
                                                                                                                                                           */

// Map { uri => { query, range } }

var MessageProcessor = exports.MessageProcessor = function () {
  function MessageProcessor(logger) {
    _classCallCheck(this, MessageProcessor);

    this._textDocumentCache = new Map();
    this._isInitialized = false;
    this._willShutdown = false;

    this._logger = logger;
  }

  MessageProcessor.prototype.handleInitializeRequest = function handleInitializeRequest(params, token, configDir) {
    var serverCapabilities, rootPath;
    return regeneratorRuntime.async(function handleInitializeRequest$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (params) {
              _context.next = 2;
              break;
            }

            throw new Error('`params` argument is required to initialize.');

          case 2:
            serverCapabilities = {
              capabilities: {
                completionProvider: { resolveProvider: true },
                definitionProvider: true,
                textDocumentSync: 1
              }
            };
            rootPath = (0, _path.dirname)((0, _graphqlConfig.findGraphQLConfigFile)(configDir ? configDir.trim() : params.rootPath));

            if (rootPath) {
              _context.next = 6;
              break;
            }

            throw new Error('`--configDir` option or `rootPath` argument is required.');

          case 6:
            _context.next = 8;
            return regeneratorRuntime.awrap((0, _GraphQLCache.getGraphQLCache)(rootPath));

          case 8:
            this._graphQLCache = _context.sent;

            this._languageService = new _graphqlLanguageServiceInterface.GraphQLLanguageService(this._graphQLCache);

            if (serverCapabilities) {
              _context.next = 12;
              break;
            }

            throw new Error('GraphQL Language Server is not initialized.');

          case 12:

            this._isInitialized = true;

            this._logger.log(JSON.stringify({
              type: 'usage',
              messageType: 'initialize'
            }));

            return _context.abrupt('return', serverCapabilities);

          case 15:
          case 'end':
            return _context.stop();
        }
      }
    }, null, this);
  };

  MessageProcessor.prototype.handleDidOpenOrSaveNotification = function handleDidOpenOrSaveNotification(params) {
    var _this = this;

    var textDocument, text, uri, diagnostics, contents, cachedDocument;
    return regeneratorRuntime.async(function handleDidOpenOrSaveNotification$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            if (this._isInitialized) {
              _context3.next = 2;
              break;
            }

            return _context3.abrupt('return', null);

          case 2:
            if (!(!params || !params.textDocument)) {
              _context3.next = 4;
              break;
            }

            throw new Error('`textDocument` argument is required.');

          case 4:
            textDocument = params.textDocument;
            text = textDocument.text, uri = textDocument.uri;
            diagnostics = [];
            contents = [];

            // Create/modify the cached entry if text is provided.
            // Otherwise, try searching the cache to perform diagnostics.

            if (text || text === '') {
              // textDocument/didSave does not pass in the text content.
              // Only run the below function if text is passed in.
              contents = getQueryAndRange(text, uri);
              this._invalidateCache(textDocument, uri, contents);
            } else {
              cachedDocument = this._getCachedDocument(uri);

              if (cachedDocument) {
                contents = cachedDocument.contents;
              }
            }

            _context3.next = 11;
            return regeneratorRuntime.awrap(Promise.all(contents.map(function _callee(_ref) {
              var query = _ref.query,
                  range = _ref.range;
              var results;
              return regeneratorRuntime.async(function _callee$(_context2) {
                while (1) {
                  switch (_context2.prev = _context2.next) {
                    case 0:
                      _context2.next = 2;
                      return regeneratorRuntime.awrap(_this._languageService.getDiagnostics(query, uri, _this._isRelayCompatMode(query) ? false : true));

                    case 2:
                      results = _context2.sent;

                      if (results && results.length > 0) {
                        diagnostics.push.apply(diagnostics, processDiagnosticsMessage(results, query, range));
                      }

                    case 4:
                    case 'end':
                      return _context2.stop();
                  }
                }
              }, null, _this);
            })));

          case 11:

            this._logger.log(JSON.stringify({
              type: 'usage',
              messageType: 'textDocument/didOpen',
              projectName: this._graphQLCache.getGraphQLConfig().getProjectNameForFile(uri),
              fileName: uri
            }));

            return _context3.abrupt('return', { uri: uri, diagnostics: diagnostics });

          case 13:
          case 'end':
            return _context3.stop();
        }
      }
    }, null, this);
  };

  MessageProcessor.prototype.handleDidChangeNotification = function handleDidChangeNotification(params) {
    var _this2 = this;

    var textDocument, contentChanges, contentChange, uri, contents, cachedDocument, diagnostics;
    return regeneratorRuntime.async(function handleDidChangeNotification$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            if (this._isInitialized) {
              _context5.next = 2;
              break;
            }

            return _context5.abrupt('return', null);

          case 2:
            if (!(!params || !params.textDocument || !params.contentChanges || !params.textDocument.uri)) {
              _context5.next = 4;
              break;
            }

            throw new Error('`textDocument`, `textDocument.uri`, and `contentChanges` arguments are required.');

          case 4:
            textDocument = params.textDocument;
            contentChanges = params.contentChanges;
            contentChange = contentChanges[contentChanges.length - 1];

            // As `contentChanges` is an array and we just want the
            // latest update to the text, grab the last entry from the array.

            uri = textDocument.uri || params.uri;

            // If it's a .js file, try parsing the contents to see if GraphQL queries
            // exist. If not found, delete from the cache.

            contents = getQueryAndRange(contentChange.text, uri);

            // If it's a .graphql file, proceed normally and invalidate the cache.

            this._invalidateCache(textDocument, uri, contents);

            cachedDocument = this._getCachedDocument(uri);

            if (cachedDocument) {
              _context5.next = 13;
              break;
            }

            return _context5.abrupt('return', null);

          case 13:

            this._updateFragmentDefinition(uri, contents);

            // Send the diagnostics onChange as well
            diagnostics = [];
            _context5.next = 17;
            return regeneratorRuntime.awrap(Promise.all(contents.map(function _callee2(_ref2) {
              var query = _ref2.query,
                  range = _ref2.range;
              var results;
              return regeneratorRuntime.async(function _callee2$(_context4) {
                while (1) {
                  switch (_context4.prev = _context4.next) {
                    case 0:
                      _context4.next = 2;
                      return regeneratorRuntime.awrap(_this2._languageService.getDiagnostics(query, uri));

                    case 2:
                      results = _context4.sent;

                      if (results && results.length > 0) {
                        diagnostics.push.apply(diagnostics, processDiagnosticsMessage(results, query, range));
                      }

                    case 4:
                    case 'end':
                      return _context4.stop();
                  }
                }
              }, null, _this2);
            })));

          case 17:

            this._logger.log(JSON.stringify({
              type: 'usage',
              messageType: 'textDocument/didChange',
              projectName: this._graphQLCache.getGraphQLConfig().getProjectNameForFile(uri),
              fileName: uri
            }));

            return _context5.abrupt('return', { uri: uri, diagnostics: diagnostics });

          case 19:
          case 'end':
            return _context5.stop();
        }
      }
    }, null, this);
  };

  MessageProcessor.prototype.handleDidCloseNotification = function handleDidCloseNotification(params) {
    if (!this._isInitialized) {
      return;
    }
    // For every `textDocument/didClose` event, delete the cached entry.
    // This is to keep a low memory usage && switch the source of truth to
    // the file on disk.
    if (!params || !params.textDocument) {
      throw new Error('`textDocument` is required.');
    }
    var textDocument = params.textDocument;
    var uri = textDocument.uri;

    if (this._textDocumentCache.has(uri)) {
      this._textDocumentCache.delete(uri);
    }

    this._logger.log(JSON.stringify({
      type: 'usage',
      messageType: 'textDocument/didClose',
      projectName: this._graphQLCache.getGraphQLConfig().getProjectNameForFile(uri),
      fileName: uri
    }));
  };

  MessageProcessor.prototype.handleShutdownRequest = function handleShutdownRequest() {
    this._willShutdown = true;
    return;
  };

  MessageProcessor.prototype.handleExitNotification = function handleExitNotification() {
    process.exit(this._willShutdown ? 0 : 1);
  };

  MessageProcessor.prototype.handleCompletionRequest = function handleCompletionRequest(params, token) {
    var textDocument, position, cachedDocument, found, query, range, result;
    return regeneratorRuntime.async(function handleCompletionRequest$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            if (this._isInitialized) {
              _context6.next = 2;
              break;
            }

            return _context6.abrupt('return', []);

          case 2:
            if (!(!params || !params.textDocument || !params.textDocument.uri || !params.position)) {
              _context6.next = 4;
              break;
            }

            throw new Error('`textDocument`, `textDocument.uri`, and `position` arguments are required.');

          case 4:
            textDocument = params.textDocument;
            position = params.position;
            cachedDocument = this._getCachedDocument(textDocument.uri);

            if (cachedDocument) {
              _context6.next = 9;
              break;
            }

            throw new Error('A cached document cannot be found.');

          case 9:
            found = cachedDocument.contents.find(function (content) {
              var currentRange = content.range;
              if (currentRange && currentRange.containsPosition(position)) {
                return true;
              }
            });

            // If there is no GraphQL query in this file, return an empty result.

            if (found) {
              _context6.next = 12;
              break;
            }

            return _context6.abrupt('return', []);

          case 12:
            query = found.query, range = found.range;


            if (range) {
              position.line -= range.start.line;
            }
            _context6.next = 16;
            return regeneratorRuntime.awrap(this._languageService.getAutocompleteSuggestions(query, position, textDocument.uri));

          case 16:
            result = _context6.sent;


            this._logger.log(JSON.stringify({
              type: 'usage',
              messageType: 'textDocument/completion',
              projectName: this._graphQLCache.getGraphQLConfig().getProjectNameForFile(textDocument.uri),
              fileName: textDocument.uri
            }));

            return _context6.abrupt('return', { items: result, isIncomplete: false });

          case 19:
          case 'end':
            return _context6.stop();
        }
      }
    }, null, this);
  };

  MessageProcessor.prototype.handleDefinitionRequest = function handleDefinitionRequest(params, token) {
    var textDocument, position, cachedDocument, found, query, range, result, formatted;
    return regeneratorRuntime.async(function handleDefinitionRequest$(_context7) {
      while (1) {
        switch (_context7.prev = _context7.next) {
          case 0:
            if (this._isInitialized) {
              _context7.next = 2;
              break;
            }

            return _context7.abrupt('return', []);

          case 2:
            if (!(!params || !params.textDocument || !params.position)) {
              _context7.next = 4;
              break;
            }

            throw new Error('`textDocument` and `position` arguments are required.');

          case 4:
            textDocument = params.textDocument;
            position = params.position;
            cachedDocument = this._getCachedDocument(textDocument.uri);

            if (cachedDocument) {
              _context7.next = 9;
              break;
            }

            throw new Error(textDocument.uri + ' is not available.');

          case 9:
            found = cachedDocument.contents.find(function (content) {
              var currentRange = content.range;
              if (currentRange && currentRange.containsPosition(position)) {
                return true;
              }
            });

            // If there is no GraphQL query in this file, return an empty result.

            if (found) {
              _context7.next = 12;
              break;
            }

            return _context7.abrupt('return', []);

          case 12:
            query = found.query, range = found.range;

            if (range) {
              position.line -= range.start.line;
            }
            _context7.next = 16;
            return regeneratorRuntime.awrap(this._languageService.getDefinition(query, position, textDocument.uri));

          case 16:
            result = _context7.sent;
            formatted = result ? result.definitions.map(function (res) {
              var defRange = res.range;
              return {
                // TODO: fix this hack!
                // URI is being misused all over this library - there's a link that
                // defines how an URI should be structured:
                // https://tools.ietf.org/html/rfc3986
                // Remove the below hack once the usage of URI is sorted out in related
                // libraries.
                uri: res.path.indexOf('file://') === 0 ? res.path : 'file://' + res.path,
                range: defRange
              };
            }) : [];


            this._logger.log(JSON.stringify({
              type: 'usage',
              messageType: 'textDocument/definition',
              projectName: this._graphQLCache.getGraphQLConfig().getProjectNameForFile(textDocument.uri),
              fileName: textDocument.uri
            }));
            return _context7.abrupt('return', formatted);

          case 20:
          case 'end':
            return _context7.stop();
        }
      }
    }, null, this);
  };

  MessageProcessor.prototype._isRelayCompatMode = function _isRelayCompatMode(query) {
    return query.indexOf('RelayCompat') !== -1 || query.indexOf('react-relay/compat') !== -1;
  };

  MessageProcessor.prototype._updateFragmentDefinition = function _updateFragmentDefinition(uri, contents) {
    var rootDir;
    return regeneratorRuntime.async(function _updateFragmentDefinition$(_context8) {
      while (1) {
        switch (_context8.prev = _context8.next) {
          case 0:
            rootDir = this._graphQLCache.getGraphQLConfig().rootDir;
            _context8.next = 3;
            return regeneratorRuntime.awrap(this._graphQLCache.updateFragmentDefinition(rootDir, new _url.URL(uri).pathname, contents));

          case 3:
          case 'end':
            return _context8.stop();
        }
      }
    }, null, this);
  };

  MessageProcessor.prototype._getCachedDocument = function _getCachedDocument(uri) {
    if (this._textDocumentCache.has(uri)) {
      var cachedDocument = this._textDocumentCache.get(uri);
      if (cachedDocument) {
        return cachedDocument;
      }
    }

    return null;
  };

  MessageProcessor.prototype._invalidateCache = function _invalidateCache(textDocument, uri, contents) {
    if (this._textDocumentCache.has(uri)) {
      var cachedDocument = this._textDocumentCache.get(uri);
      if (cachedDocument && cachedDocument.version < textDocument.version) {
        // Current server capabilities specify the full sync of the contents.
        // Therefore always overwrite the entire content.
        this._textDocumentCache.set(uri, {
          version: textDocument.version,
          contents: contents
        });
      }
    } else {
      this._textDocumentCache.set(uri, {
        version: textDocument.version,
        contents: contents
      });
    }
  };

  return MessageProcessor;
}();

/**
 * Helper functions to perform requested services from client/server.
 */

// Check the uri to determine the file type (JavaScript/GraphQL).
// If .js file, either return the parsed query/range or null if GraphQL queries
// are not found.


function getQueryAndRange(text, uri) {
  // Check if the text content includes a GraphQLV query.
  // If the text doesn't include GraphQL queries, do not proceed.
  if ((0, _path.extname)(uri) === '.js') {
    if (text.indexOf('graphql`') === -1 && text.indexOf('graphql.experimental`') === -1) {
      return [];
    }
    var templates = (0, _findGraphQLTags.findGraphQLTags)(text);
    return templates.map(function (_ref3) {
      var template = _ref3.template,
          range = _ref3.range;
      return { query: template, range: range };
    });
  } else {
    var query = text;
    if (!query && query !== '') {
      return [];
    }
    var lines = query.split('\n');
    var range = new _graphqlLanguageServiceUtils.Range(new _graphqlLanguageServiceUtils.Position(0, 0), new _graphqlLanguageServiceUtils.Position(lines.length - 1, lines[lines.length - 1].length - 1));
    return [{ query: query, range: range }];
  }
}

function processDiagnosticsMessage(results, query, range) {
  var queryLines = query.split('\n');
  var totalLines = queryLines.length;
  var lastLineLength = queryLines[totalLines - 1].length;
  var lastCharacterPosition = new _graphqlLanguageServiceUtils.Position(totalLines, lastLineLength);
  var processedResults = results.filter(function (diagnostic) {
    return diagnostic.range.end.lessThanOrEqualTo(lastCharacterPosition);
  });

  if (range) {
    var offset = range.start;
    return processedResults.map(function (diagnostic) {
      return _extends({}, diagnostic, {
        range: new _graphqlLanguageServiceUtils.Range(new _graphqlLanguageServiceUtils.Position(diagnostic.range.start.line + offset.line, diagnostic.range.start.character), new _graphqlLanguageServiceUtils.Position(diagnostic.range.end.line + offset.line, diagnostic.range.end.character))
      });
    });
  }

  return processedResults;
}