'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GraphQLCache = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.getGraphQLCache = getGraphQLCache;

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _graphql = require('graphql');

var _nullthrows = require('nullthrows');

var _nullthrows2 = _interopRequireDefault(_nullthrows);

var _kinds = require('graphql/language/kinds');

var _graphqlConfig = require('graphql-config');

var _GraphQLWatchman = require('./GraphQLWatchman');

var _MessageProcessor = require('./MessageProcessor');

var _stringToHash = require('./stringToHash');

var _stringToHash2 = _interopRequireDefault(_stringToHash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /**
                                                                                                                                                           *  Copyright (c) Facebook, Inc.
                                                                                                                                                           *  All rights reserved.
                                                                                                                                                           *
                                                                                                                                                           *  This source code is licensed under the license found in the
                                                                                                                                                           *  LICENSE file in the root directory of this source tree.
                                                                                                                                                           *
                                                                                                                                                           *  
                                                                                                                                                           */

// Maximum files to read when processing GraphQL files.
var MAX_READS = 200;

function getGraphQLCache(configDir) {
  var graphQLConfig, watchmanClient;
  return regeneratorRuntime.async(function getGraphQLCache$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          _context.next = 2;
          return regeneratorRuntime.awrap((0, _graphqlConfig.getGraphQLConfig)(configDir));

        case 2:
          graphQLConfig = _context.sent;
          watchmanClient = new _GraphQLWatchman.GraphQLWatchman();

          watchmanClient.checkVersion();
          watchmanClient.watchProject(configDir);
          return _context.abrupt('return', new GraphQLCache(configDir, graphQLConfig, watchmanClient));

        case 7:
        case 'end':
          return _context.stop();
      }
    }
  }, null, this);
}

var GraphQLCache = exports.GraphQLCache = function () {
  function GraphQLCache(configDir, graphQLConfig, watchmanClient) {
    var _this = this;

    _classCallCheck(this, GraphQLCache);

    this.getGraphQLConfig = function () {
      return _this._graphQLConfig;
    };

    this.getFragmentDependencies = function _callee(query, fragmentDefinitions) {
      var parsedQuery;
      return regeneratorRuntime.async(function _callee$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (fragmentDefinitions) {
                _context2.next = 2;
                break;
              }

              return _context2.abrupt('return', []);

            case 2:
              // If the query cannot be parsed, validations cannot happen yet.
              // Return an empty array.
              parsedQuery = void 0;
              _context2.prev = 3;

              parsedQuery = (0, _graphql.parse)(query);
              _context2.next = 10;
              break;

            case 7:
              _context2.prev = 7;
              _context2.t0 = _context2['catch'](3);
              return _context2.abrupt('return', []);

            case 10:
              return _context2.abrupt('return', _this.getFragmentDependenciesForAST(parsedQuery, fragmentDefinitions));

            case 11:
            case 'end':
              return _context2.stop();
          }
        }
      }, null, _this, [[3, 7]]);
    };

    this.getFragmentDependenciesForAST = function _callee2(parsedQuery, fragmentDefinitions) {
      var existingFrags, referencedFragNames, asts, referencedFragments;
      return regeneratorRuntime.async(function _callee2$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              if (fragmentDefinitions) {
                _context3.next = 2;
                break;
              }

              return _context3.abrupt('return', []);

            case 2:
              existingFrags = new Map();
              referencedFragNames = new Set();


              (0, _graphql.visit)(parsedQuery, {
                FragmentDefinition: function FragmentDefinition(node) {
                  existingFrags.set(node.name.value, true);
                },
                FragmentSpread: function FragmentSpread(node) {
                  if (!referencedFragNames.has(node.name.value)) {
                    referencedFragNames.add(node.name.value);
                  }
                }
              });

              asts = new Set();

              referencedFragNames.forEach(function (name) {
                if (!existingFrags.has(name) && fragmentDefinitions.has(name)) {
                  asts.add((0, _nullthrows2.default)(fragmentDefinitions.get(name)));
                }
              });

              referencedFragments = [];


              asts.forEach(function (ast) {
                (0, _graphql.visit)(ast.definition, {
                  FragmentSpread: function FragmentSpread(node) {
                    if (!referencedFragNames.has(node.name.value) && fragmentDefinitions.get(node.name.value)) {
                      asts.add((0, _nullthrows2.default)(fragmentDefinitions.get(node.name.value)));
                      referencedFragNames.add(node.name.value);
                    }
                  }
                });
                if (!existingFrags.has(ast.definition.name.value)) {
                  referencedFragments.push(ast);
                }
              });

              return _context3.abrupt('return', referencedFragments);

            case 10:
            case 'end':
              return _context3.stop();
          }
        }
      }, null, _this);
    };

    this.getFragmentDefinitions = function _callee3(projectConfig) {
      var rootDir, includes, filesFromInputDirs, list, _ref, fragmentDefinitions, graphQLFileMap;

      return regeneratorRuntime.async(function _callee3$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              // This function may be called from other classes.
              // If then, check the cache first.
              rootDir = projectConfig.configDir;

              if (!_this._fragmentDefinitionsCache.has(rootDir)) {
                _context4.next = 3;
                break;
              }

              return _context4.abrupt('return', _this._fragmentDefinitionsCache.get(rootDir) || new Map());

            case 3:
              includes = projectConfig.includes.map(function (filePath) {
                return filePath.split('*')[0];
              });
              _context4.next = 6;
              return regeneratorRuntime.awrap(_this._watchmanClient.listFiles(rootDir, {
                path: includes
              }));

            case 6:
              filesFromInputDirs = _context4.sent;
              list = filesFromInputDirs.map(function (fileInfo) {
                return {
                  filePath: _path2.default.join(rootDir, fileInfo.name),
                  size: fileInfo.size,
                  mtime: fileInfo.mtime
                };
              }).filter(function (fileInfo) {
                return projectConfig.includesFile(fileInfo.filePath);
              });
              _context4.next = 10;
              return regeneratorRuntime.awrap(_this.readAllGraphQLFiles(list));

            case 10:
              _ref = _context4.sent;
              fragmentDefinitions = _ref.fragmentDefinitions;
              graphQLFileMap = _ref.graphQLFileMap;


              _this._fragmentDefinitionsCache.set(rootDir, fragmentDefinitions);
              _this._graphQLFileListCache.set(rootDir, graphQLFileMap);

              _this._subscribeToFileChanges(rootDir, projectConfig);

              return _context4.abrupt('return', fragmentDefinitions);

            case 17:
            case 'end':
              return _context4.stop();
          }
        }
      }, null, _this);
    };

    this.getSchema = function _callee4(appName) {
      var queryHasExtensions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      var projectConfig, projectName, schemaPath, schemaCacheKey, _schema, schema, customDirectives, directivesSDL;

      return regeneratorRuntime.async(function _callee4$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              projectConfig = _this._graphQLConfig.getProjectConfig(appName);

              if (!(!projectConfig || !projectConfig.schemaPath)) {
                _context5.next = 3;
                break;
              }

              return _context5.abrupt('return', null);

            case 3:
              projectName = appName || 'undefinedName';
              schemaPath = projectConfig.schemaPath;
              schemaCacheKey = schemaPath + ':' + projectName;

              if (!_this._schemaMap.has(schemaCacheKey)) {
                _context5.next = 9;
                break;
              }

              _schema = _this._schemaMap.get(schemaCacheKey);
              return _context5.abrupt('return', _schema && queryHasExtensions ? _this._extendSchema(_schema, schemaPath, projectName) : _schema);

            case 9:
              schema = projectConfig.getSchema();
              customDirectives = projectConfig.extensions.customDirectives;

              if (customDirectives && schema) {
                directivesSDL = customDirectives.join('\n\n');

                schema = (0, _graphql.extendSchema)(schema, (0, _graphql.parse)(directivesSDL));
              }

              if (schema) {
                _context5.next = 14;
                break;
              }

              return _context5.abrupt('return', null);

            case 14:

              if (_this._graphQLFileListCache.has(_this._configDir)) {
                schema = _this._extendSchema(schema, schemaPath, projectName);
              }

              _this._schemaMap.set(schemaCacheKey, schema);
              return _context5.abrupt('return', schema);

            case 17:
            case 'end':
              return _context5.stop();
          }
        }
      }, null, _this);
    };

    this.readAllGraphQLFiles = function _callee5(list) {
      var queue, responses, chunk, promises;
      return regeneratorRuntime.async(function _callee5$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              queue = list.slice(); // copy

              responses = [];

            case 2:
              if (!queue.length) {
                _context6.next = 9;
                break;
              }

              chunk = queue.splice(0, MAX_READS);
              promises = chunk.map(function (fileInfo) {
                return _this.promiseToReadGraphQLFile(fileInfo.filePath).catch(function (error) {
                  /**
                  * fs emits `EMFILE | ENFILE` error when there are too many
                  * open files - this can cause some fragment files not to be
                  * processed.  Solve this case by implementing a queue to save
                  * files failed to be processed because of `EMFILE` error,
                  * and await on Promises created with the next batch from the
                  * queue.
                  */
                  if (error.code === 'EMFILE' || error.code === 'ENFILE') {
                    queue.push(fileInfo);
                  }
                }).then(function (response) {
                  return responses.push(_extends({}, response, {
                    mtime: fileInfo.mtime,
                    size: fileInfo.size
                  }));
                });
              });
              _context6.next = 7;
              return regeneratorRuntime.awrap(Promise.all(promises));

            case 7:
              _context6.next = 2;
              break;

            case 9:
              return _context6.abrupt('return', _this.processGraphQLFiles(responses));

            case 10:
            case 'end':
              return _context6.stop();
          }
        }
      }, null, _this);
    };

    this.processGraphQLFiles = function (responses) {
      var fragmentDefinitions = new Map();
      var graphQLFileMap = new Map();

      responses.forEach(function (response) {
        var filePath = response.filePath,
            content = response.content,
            asts = response.asts,
            mtime = response.mtime,
            size = response.size;


        if (asts) {
          asts.forEach(function (ast) {
            ast.definitions.forEach(function (definition) {
              if (definition.kind === _kinds.FRAGMENT_DEFINITION) {
                fragmentDefinitions.set(definition.name.value, {
                  filePath: filePath,
                  content: content,
                  definition: definition
                });
              }
            });
          });
        }

        // Relay the previous object whether or not ast exists.
        graphQLFileMap.set(filePath, {
          filePath: filePath,
          content: content,
          asts: asts,
          mtime: mtime,
          size: size
        });
      });

      return { fragmentDefinitions: fragmentDefinitions, graphQLFileMap: graphQLFileMap };
    };

    this.promiseToReadGraphQLFile = function (filePath) {
      return new Promise(function (resolve, reject) {
        return _fs2.default.readFile(filePath, 'utf8', function (error, content) {
          if (error) {
            reject(error);
            return;
          }

          var asts = [];
          var queries = [];
          if (content.trim().length !== 0) {
            try {
              queries = (0, _MessageProcessor.getQueryAndRange)(content, filePath);
              if (queries.length === 0) {
                // still resolve with an empty ast
                resolve({ filePath: filePath, content: content, asts: [], queries: [] });
                return;
              }

              queries.forEach(function (_ref2) {
                var query = _ref2.query;
                return asts.push((0, _graphql.parse)(query));
              });
            } catch (_) {
              // If query has syntax errors, go ahead and still resolve
              // the filePath and the content, but leave ast empty.
              resolve({ filePath: filePath, content: content, asts: [], queries: [] });
              return;
            }
          }
          resolve({ filePath: filePath, content: content, asts: asts, queries: queries });
        });
      });
    };

    this._configDir = configDir;
    this._graphQLConfig = graphQLConfig;
    this._watchmanClient = watchmanClient || new _GraphQLWatchman.GraphQLWatchman();
    this._graphQLFileListCache = new Map();
    this._schemaMap = new Map();
    this._fragmentDefinitionsCache = new Map();
    this._typeExtensionMap = new Map();
  }

  /**
   * Subscribes to the file changes and update the cache accordingly.
   * @param `rootDir` the directory of config path
   */
  GraphQLCache.prototype._subscribeToFileChanges = function _subscribeToFileChanges(rootDir, projectConfig) {
    var _this2 = this;

    this._watchmanClient.subscribe(this._configDir, function (result) {
      if (result.files && result.files.length > 0) {
        var _graphQLFileMap = _this2._graphQLFileListCache.get(rootDir);
        if (!_graphQLFileMap) {
          return;
        }
        result.files.forEach(function _callee6(_ref3) {
          var name = _ref3.name,
              exists = _ref3.exists,
              size = _ref3.size,
              mtime = _ref3.mtime;
          var filePath, existingFile, fileAndContent;
          return regeneratorRuntime.async(function _callee6$(_context7) {
            while (1) {
              switch (_context7.prev = _context7.next) {
                case 0:
                  if (projectConfig.includesFile(name)) {
                    _context7.next = 2;
                    break;
                  }

                  return _context7.abrupt('return');

                case 2:
                  filePath = _path2.default.join(result.root, result.subscription, name);

                  // In the event of watchman recrawl (is_fresh_instance),
                  // watchman subscription returns a full set of files within the
                  // watched directory. After pruning with input/excluded directories,
                  // the file could have been created/modified.
                  // Using the cached size/mtime information, only cache the file if
                  // the file doesn't exist or the file exists and one of or both
                  // size/mtime is different.

                  if (!(result.is_fresh_instance && exists)) {
                    _context7.next = 13;
                    break;
                  }

                  existingFile = _graphQLFileMap.get(filePath);
                  // Same size/mtime means the file stayed the same

                  if (!(existingFile && existingFile.size === size && existingFile.mtime === mtime)) {
                    _context7.next = 7;
                    break;
                  }

                  return _context7.abrupt('return');

                case 7:
                  _context7.next = 9;
                  return regeneratorRuntime.awrap(_this2.promiseToReadGraphQLFile(filePath));

                case 9:
                  fileAndContent = _context7.sent;

                  _graphQLFileMap.set(filePath, _extends({}, fileAndContent, {
                    size: size,
                    mtime: mtime
                  }));
                  // Otherwise, create/update the cache with the updated file and
                  // content, or delete the cache if (!exists)
                  _context7.next = 21;
                  break;

                case 13:
                  if (!_graphQLFileMap) {
                    _context7.next = 20;
                    break;
                  }

                  _context7.t0 = _this2._graphQLFileListCache;
                  _context7.t1 = rootDir;
                  _context7.next = 18;
                  return regeneratorRuntime.awrap(_this2._updateGraphQLFileListCache(_graphQLFileMap, { size: size, mtime: mtime }, filePath, exists));

                case 18:
                  _context7.t2 = _context7.sent;

                  _context7.t0.set.call(_context7.t0, _context7.t1, _context7.t2);

                case 20:

                  _this2._updateFragmentDefinitionCache(rootDir, filePath, exists);

                case 21:
                case 'end':
                  return _context7.stop();
              }
            }
          }, null, _this2);
        });
      }
    });
  };

  GraphQLCache.prototype._updateGraphQLFileListCache = function _updateGraphQLFileListCache(graphQLFileMap, metrics, filePath, exists) {
    var fileAndContent, graphQLFileInfo, existingFile;
    return regeneratorRuntime.async(function _updateGraphQLFileListCache$(_context8) {
      while (1) {
        switch (_context8.prev = _context8.next) {
          case 0:
            if (!exists) {
              _context8.next = 6;
              break;
            }

            _context8.next = 3;
            return regeneratorRuntime.awrap(this.promiseToReadGraphQLFile(filePath));

          case 3:
            _context8.t0 = _context8.sent;
            _context8.next = 7;
            break;

          case 6:
            _context8.t0 = null;

          case 7:
            fileAndContent = _context8.t0;
            graphQLFileInfo = _extends({}, fileAndContent, metrics);
            existingFile = graphQLFileMap.get(filePath);

            // 3 cases for the cache invalidation: create/modify/delete.
            // For create/modify, swap the existing entry if available;
            // otherwise, just push in the new entry created.
            // For delete, check `exists` and splice the file out.

            if (existingFile && !exists) {
              graphQLFileMap.delete(filePath);
            } else if (graphQLFileInfo) {
              graphQLFileMap.set(filePath, graphQLFileInfo);
            }

            return _context8.abrupt('return', graphQLFileMap);

          case 12:
          case 'end':
            return _context8.stop();
        }
      }
    }, null, this);
  };

  GraphQLCache.prototype.updateFragmentDefinition = function updateFragmentDefinition(rootDir, filePath, contents) {
    var cache, asts;
    return regeneratorRuntime.async(function updateFragmentDefinition$(_context9) {
      while (1) {
        switch (_context9.prev = _context9.next) {
          case 0:
            cache = this._fragmentDefinitionsCache.get(rootDir);
            asts = contents.map(function (_ref4) {
              var query = _ref4.query;

              try {
                return { ast: (0, _graphql.parse)(query), query: query };
              } catch (error) {
                return { ast: null, query: query };
              }
            });

            if (cache) {
              // first go through the fragment list to delete the ones from this file
              cache.forEach(function (value, key) {
                if (value.filePath === filePath) {
                  cache.delete(key);
                }
              });
              asts.forEach(function (_ref5) {
                var ast = _ref5.ast,
                    query = _ref5.query;

                if (!ast) {
                  return;
                }
                ast.definitions.forEach(function (definition) {
                  if (definition.kind === _kinds.FRAGMENT_DEFINITION) {
                    cache.set(definition.name.value, {
                      filePath: filePath,
                      content: query,
                      definition: definition
                    });
                  }
                });
              });
            }

          case 3:
          case 'end':
            return _context9.stop();
        }
      }
    }, null, this);
  };

  GraphQLCache.prototype._updateFragmentDefinitionCache = function _updateFragmentDefinitionCache(rootDir, filePath, exists) {
    var fileAndContent, cache;
    return regeneratorRuntime.async(function _updateFragmentDefinitionCache$(_context10) {
      while (1) {
        switch (_context10.prev = _context10.next) {
          case 0:
            if (!exists) {
              _context10.next = 6;
              break;
            }

            _context10.next = 3;
            return regeneratorRuntime.awrap(this.promiseToReadGraphQLFile(filePath));

          case 3:
            _context10.t0 = _context10.sent;
            _context10.next = 7;
            break;

          case 6:
            _context10.t0 = null;

          case 7:
            fileAndContent = _context10.t0;

            // In the case of fragment definitions, the cache could just map the
            // definition name to the parsed ast, whether or not it existed
            // previously.
            // For delete, remove the entry from the set.
            if (!exists) {
              cache = this._fragmentDefinitionsCache.get(rootDir);

              if (cache) {
                cache.delete(filePath);
              }
            } else if (fileAndContent && fileAndContent.queries) {
              this.updateFragmentDefinition(rootDir, filePath, fileAndContent.queries);
            }

          case 9:
          case 'end':
            return _context10.stop();
        }
      }
    }, null, this);
  };

  GraphQLCache.prototype._extendSchema = function _extendSchema(schema, schemaPath, projectName) {
    var graphQLFileMap = this._graphQLFileListCache.get(this._configDir);
    var typeExtensions = [];

    if (!graphQLFileMap) {
      return schema;
    }
    graphQLFileMap.forEach(function (_ref6) {
      var filePath = _ref6.filePath,
          asts = _ref6.asts;

      asts.forEach(function (ast) {
        if (filePath === schemaPath) {
          return;
        }
        ast.definitions.forEach(function (definition) {
          switch (definition.kind) {
            case _kinds.OBJECT_TYPE_DEFINITION:
            case _kinds.INTERFACE_TYPE_DEFINITION:
            case _kinds.ENUM_TYPE_DEFINITION:
            case _kinds.UNION_TYPE_DEFINITION:
            case _kinds.SCALAR_TYPE_DEFINITION:
            case _kinds.INPUT_OBJECT_TYPE_DEFINITION:
            case _kinds.TYPE_EXTENSION_DEFINITION:
            case _kinds.DIRECTIVE_DEFINITION:
              typeExtensions.push(definition);
              break;
          }
        });
      });
    });
    var sorted = typeExtensions.sort(function (a, b) {
      var aName = a.definition ? a.definition.name.value : a.name.value;
      var bName = b.definition ? b.definition.name.value : b.name.value;
      return aName > bName ? 1 : -1;
    });

    var hash = (0, _stringToHash2.default)(JSON.stringify(sorted));
    var typeExtCacheKey = schemaPath + ':' + projectName;
    if (this._typeExtensionMap.has(typeExtCacheKey) && this._typeExtensionMap.get(typeExtCacheKey) === hash) {
      return schema;
    }

    this._typeExtensionMap.set(typeExtCacheKey, hash);
    return (0, _graphql.extendSchema)(schema, {
      kind: _kinds.DOCUMENT,
      definitions: typeExtensions
    });
  };

  /**
  * Given a list of GraphQL file metadata, read all files collected from watchman
  * and create fragmentDefinitions and GraphQL files cache.
  */


  /**
  * Takes an array of GraphQL File information and batch-processes into a
  * map of fragmentDefinitions and GraphQL file cache.
  */


  /**
  * Returns a Promise to read a GraphQL file and return a GraphQL metadata
  * including a parsed AST.
  */


  return GraphQLCache;
}();