import { DebugProtocol } from 'vscode-debugprotocol';
import { LoggingDebugSession } from 'vscode-debugadapter';
import { ChromeDebugAdapter } from './chromeDebugAdapter';
import { ITargetFilter, ChromeConnection } from './chromeConnection';
import { BasePathTransformer } from '../transformers/basePathTransformer';
import { BaseSourceMapTransformer } from '../transformers/baseSourceMapTransformer';
import { LineColTransformer } from '../transformers/lineNumberTransformer';
export interface IChromeDebugAdapterOpts {
    targetFilter?: ITargetFilter;
    logFilePath?: string;
    enableSourceMapCaching?: boolean;
    chromeConnection?: typeof ChromeConnection;
    pathTransformer?: {
        new (): BasePathTransformer;
    };
    sourceMapTransformer?: {
        new (sourceHandles: any, enableSourcemapCaching?: boolean): BaseSourceMapTransformer;
    };
    lineColTransformer?: {
        new (session: any): LineColTransformer;
    };
}
export interface IChromeDebugSessionOpts extends IChromeDebugAdapterOpts {
    /** The class of the adapter, which is instantiated for each session */
    adapter: typeof ChromeDebugAdapter;
    extensionName: string;
}
export declare class ChromeDebugSession extends LoggingDebugSession {
    private _debugAdapter;
    private _extensionName;
    /**
     * This needs a bit of explanation -
     * The Session is reinstantiated for each session, but consumers need to configure their instance of
     * ChromeDebugSession. Consumers should call getSession with their config options, then call
     * DebugSession.run with the result. Alternatively they could subclass ChromeDebugSession and pass
     * their options to the super constructor, but I think this is easier to follow.
     */
    static getSession(opts: IChromeDebugSessionOpts): typeof ChromeDebugSession;
    constructor(obsolete_debuggerLinesAndColumnsStartAt1?: boolean, obsolete_isServer?: boolean, opts?: IChromeDebugSessionOpts);
    /**
     * Takes a response and a promise to the response body. If the promise is successful, assigns the response body and sends the response.
     * If the promise fails, sets the appropriate response parameters and sends the response.
     */
    private sendResponseAsync(request, response, responseP);
    /**
     * Overload dispatchRequest to the debug adapters' Promise-based methods instead of DebugSession's callback-based methods
     */
    protected dispatchRequest(request: DebugProtocol.Request): void;
    private failedRequest(requestType, response, error);
    private sendUnknownCommandResponse(response, command);
}
