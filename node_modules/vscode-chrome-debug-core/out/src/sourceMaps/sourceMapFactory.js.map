{"version":3,"sources":["src/sourceMaps/sourceMapFactory.ts"],"names":[],"mappings":"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","file":"sourceMapFactory.js","sourcesContent":["/*---------------------------------------------------------\n * Copyright (C) Microsoft Corporation. All rights reserved.\n *--------------------------------------------------------*/\n\nimport * as fs from 'fs';\nimport * as crypto from 'crypto';\nimport * as path from 'path';\nimport * as os from 'os';\n\nimport * as sourceMapUtils from './sourceMapUtils';\nimport * as utils from '../utils';\nimport {logger} from 'vscode-debugadapter';\nimport {SourceMap} from './sourceMap';\nimport {ISourceMapPathOverrides} from '../debugAdapterInterfaces';\n\nexport class SourceMapFactory {\n    constructor(\n        private _webRoot?: string,\n        private _sourceMapPathOverrides?: ISourceMapPathOverrides,\n        private _enableSourceMapCaching?: boolean) {\n    }\n\n    /**\n     * pathToGenerated - an absolute local path or a URL.\n     * mapPath - a path relative to pathToGenerated.\n     */\n    getMapForGeneratedPath(pathToGenerated: string, mapPath: string): Promise<SourceMap> {\n        let msg = `SourceMaps.getMapForGeneratedPath: Finding SourceMap for ${pathToGenerated} by URI: ${mapPath}`;\n        if (this._webRoot) {\n            msg += ` and webRoot: ${this._webRoot}`;\n        }\n\n        logger.log(msg);\n\n        // For an inlined sourcemap, mapPath is a data URI containing a blob of base64 encoded data, starting\n        // with a tag like \"data:application/json;charset:utf-8;base64,\". The data should start after the last comma.\n        let sourceMapContentsP: Promise<string>;\n        if (mapPath.indexOf('data:application/json') >= 0) {\n            // Sourcemap is inlined\n            logger.log(`SourceMaps.getMapForGeneratedPath: Using inlined sourcemap in ${pathToGenerated}`);\n            sourceMapContentsP = Promise.resolve(this.getInlineSourceMapContents(mapPath));\n        } else {\n            sourceMapContentsP = this.getSourceMapContent(pathToGenerated, mapPath);\n        }\n\n        return sourceMapContentsP.then(contents => {\n            if (contents) {\n                try {\n                    // Throws for invalid JSON\n                    return new SourceMap(pathToGenerated, contents, this._webRoot, this._sourceMapPathOverrides);\n                } catch (e) {\n                    logger.error(`SourceMaps.getMapForGeneratedPath: exception while processing path: ${pathToGenerated}, sourcemap: ${mapPath}\\n${e.stack}`);\n                    return null;\n                }\n            } else {\n                return null;\n            }\n        });\n    }\n\n    /**\n     * Parses sourcemap contents from inlined base64-encoded data\n     */\n    private getInlineSourceMapContents(sourceMapData: string): string {\n        const lastCommaPos = sourceMapData.lastIndexOf(',');\n        if (lastCommaPos < 0) {\n            logger.log(`SourceMaps.getInlineSourceMapContents: Inline sourcemap is malformed. Starts with: ${sourceMapData.substr(0, 200)}`);\n            return null;\n        }\n\n        const data = sourceMapData.substr(lastCommaPos + 1);\n        try {\n            const buffer = new Buffer(data, 'base64');\n            return buffer.toString();\n        } catch (e) {\n            logger.error(`SourceMaps.getInlineSourceMapContents: exception while processing data uri (${e.stack})`);\n        }\n\n        return null;\n    }\n\n    /**\n     * Resolves a sourcemap's path and loads the data\n     */\n    private getSourceMapContent(pathToGenerated: string, mapPath: string): Promise<string> {\n        mapPath = sourceMapUtils.resolveMapPath(pathToGenerated, mapPath);\n        if (!mapPath) {\n            return Promise.resolve(null);\n        }\n\n        return this.loadSourceMapContents(mapPath).then(contents => {\n            if (!contents) {\n                // Last ditch effort - just look for a .js.map next to the script\n                const mapPathNextToSource = pathToGenerated + '.map';\n                if (mapPathNextToSource !== mapPath) {\n                    return this.loadSourceMapContents(mapPathNextToSource);\n                }\n            }\n\n            return contents;\n        });\n    }\n\n    private loadSourceMapContents(mapPathOrURL: string): Promise<string> {\n        let contentsP: Promise<string>;\n        if (utils.isURL(mapPathOrURL) && !utils.isFileUrl(mapPathOrURL)) {\n            logger.log(`SourceMaps.loadSourceMapContents: Downloading sourcemap file from ${mapPathOrURL}`);\n            contentsP = this.downloadSourceMapContents(mapPathOrURL).catch(e => {\n                logger.error(`SourceMaps.loadSourceMapContents: Could not download sourcemap from ${mapPathOrURL}`);\n                return null;\n            });\n        } else {\n            mapPathOrURL = utils.canonicalizeUrl(mapPathOrURL);\n            contentsP = new Promise((resolve, reject) => {\n                logger.log(`SourceMaps.loadSourceMapContents: Reading local sourcemap file from ${mapPathOrURL}`);\n                fs.readFile(mapPathOrURL, (err, data) => {\n                    if (err) {\n                        logger.log(`SourceMaps.loadSourceMapContents: Could not read sourcemap file - ` + err.message);\n                        resolve(null);\n                    } else {\n                        resolve(data && data.toString());\n                    }\n                });\n            });\n        }\n\n        return contentsP;\n    }\n\n    private async downloadSourceMapContents(sourceMapUri: string): Promise<string> {\n        // use sha256 to ensure the hash value can be used in filenames\n        let cachedSourcemapPath: string;\n        if (this._enableSourceMapCaching) {\n            const hash = crypto.createHash('sha256').update(sourceMapUri).digest('hex');\n\n            const cachePath = path.join(os.tmpdir(), 'com.microsoft.VSCode', 'node-debug2', 'sm-cache');\n            cachedSourcemapPath = path.join(cachePath, hash);\n\n            const exists = utils.existsSync(cachedSourcemapPath);\n            if (exists) {\n                logger.log(`Sourcemaps.downloadSourceMapContents: Reading cached sourcemap file from ${cachedSourcemapPath}`);\n                return this.loadSourceMapContents(cachedSourcemapPath);\n            }\n        }\n\n        const responseText = await utils.getURL(sourceMapUri);\n        if (cachedSourcemapPath) {\n            logger.log(`Sourcemaps.downloadSourceMapContents: Caching sourcemap file at ${cachedSourcemapPath}`);\n            await utils.writeFileP(cachedSourcemapPath, responseText);\n        }\n\n        return responseText;\n    }\n}\n"],"sourceRoot":"../../.."}